-- ********************************************************************
-- **********************  Examples les 06  ***************************
-- *************  Транзакции, переменные, представления  **************
-- ********************************************************************
-- *** Урок 6 ч.1 Транзакции ***
-- 01. Транзакция
-- 02. Ключ.сл. COMMIT и ROLLBACK
-- 03. Точки сохранения
-- 04. Режим автозавершения транзакций
-- 05. Принцип ACID
-- 06. Уровни изоляции
-- mysql -uroot -p123456 -P3360

-- Таблица accounts
CREATE TABLE accounts (
	id SERIAL PRIMARY KEY,
	user_id INT,
	total DECIMAL(11,2) COMMENT 'Счет',
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
	updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Счета пользователей и интернет магазина';

INSERT INTO
	accounts (user_id, total)
VALUES
	(4, 5000.00),
	(3, 0.00),
	(2, 2000.00),
	(NULL, 25000.00);

SELECT id, user_id, total FROM accounts;

-- Все готово можно начинать транзакцию
START TRANSACTION;

-- вводим команды входящие в транзакцию
-- убеждаемся, что у пользователя достаточно денежных средств 
SELECT total FROM accounts WHERE user_id = 4;

-- снимаем денеж.ср.со счета пользователя
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;

-- и перемещаем их на счет интернет магазина
UPDATE accounts SET total = total + 2000 WHERE user_id IS NULL;

-- Проверяем таблицу accounts
SELECT * FROM accounts;

-----------------------------------------------------------------
-- !!! На текущий момент ТРАНЗАКЦИИ изменения НЕ СОХРАНЕНЫ !!! --
-- Это можно проверить открывь новую сессию через консоль -------
-- Что бы изменения вступили в силу необходимо выполнить COMMIT -
-----------------------------------------------------------------

COMMIT;
-- *

-- Транзакции можно отменять самостоятельно
START TRANSACTION;
-- убеждаемся, что у пользователя достаточно денежных средств 
SELECT total FROM accounts WHERE user_id = 4;
-- снимаем денеж.ср.со счета пользователя
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
-- и перемещаем их на счет интернет магазина
UPDATE accounts SET total = total + 2000 WHERE user_id IS NULL;

-- на текущем моменте можно отказаться от изменений перед COMMT --
ROLLBACK;

-- !!! Для ROLLBACK сущ. необратимые команды: !!!
-- CREATE INDEX, DROP INDEX, CREATE TABLE, DROP TABLE,
-- TRUNCATE TABLE, ALTER TABLE, RENAME TABLE, CREATE DATABASE,
-- DROP DATABASE, ALTER DATABASE

-- !!! Неявное завершение транзакций !!! --
-- ALTER TABLE, BEGIN, CREATE INDEX, CREATE TABLE, CREATE DATABASE,
-- DROP DATABASE, DROP INDEX, DROP TABLE, LOAD MASTER DATA,
-- LOCK TABLE, RENAME, AET AUTOCOMMIT=1, START TRANSACTION,
-- TRUNCATE TABLE



DELETE FROM accounts WHERE total = 5000;
UPDATE accounts SET total = 29000.00 WHERE user_id is NULL;

-- Команды для точек сохранения --
-- * SAVEPOINT -- Создает точку восстановления
-- * ROLLBACK TO SAVEPOINT -- Возвращает к SAVEPOINT <name>
START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;
SAVEPOINT accounts_4; -- создаем точку восстановления
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
-- возврат к SAVEPOINT accounts_4
ROLLBACK TO SAVEPOINT accounts_4;
-- Допускается создавать несколько точек восстановления
-- если название старой точ.вост. дублируется, то старая затирается новой.
-- Все точ.вост. удаляются если используется оператор 
-- COMMIT или ROLLBACK без указания точ.вост.
-- пока мы не использ. START TRANSACTION, каждая операция 
-- в mysql рассматривается как отдельная транзакция.
-- обычно говорят, что mysql Работает в режиме авто-завершения 
-- транзакции.
-- !!! при помощи команды SET AUTOCOMMIT=0 !!!
-- мы можем отключить такой режим и любая последовательность команд
-- будет рассматриваться как транзакция, т.е. в этом случае 
-- опускается START TRANSACTION и когда нам надо завершить Т.А. 
-- мы используем COMMIT или для отмены действий ROLLBACK;
-- !!! Что бы обратно ВКЛ реж. обычный реж. COMMIT использ.
-- SET AUTOCOMMIT=1; !!!
-- ************************************************
-- ** Транзакция обязана удовлетв. принцип ACID  **
-- ** A - Atomic - атомарность					 **
-- ** C - Consistency - согласованность		 	 **
-- ** I - Isolation - изолированность			 **
-- ** D - Durability - сохраняемость			 **
-- ************************************************


-- * Уровни изоляции Транзакции менее строгого к более строгому
-- READ UNCOMMITTED - транзакции могут видет изменеия не закомиченных тр.акц.
-- READ COMMITTED - использ. редко
-- REPEATABLE READ - стоит по умолчанию
-- SERIALIZABLE - использ. редко
-- Для изменения реж. использ.:
-- SET TRANSACTION ISOLATION LEVEL READ COMMITED;

-- 						   ***			    		--


-- ***************************************************
-- *** Урок 6 ч.2 Внутренняя реализация транзакций ***
-- * 01. Блокировка и Взаимоблокировка
-- * 02. Журнал транзакций
-- * 03. Управление режимом сохранения транзакций
-- * 04. MVCC
-- * 05. Связь MVCC с уровнями изоляции

-- * Блокировка *
-- начнем тр.акц. в 2х разных сессиях
--  1я сессия --
START TRANSACTION;
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
UPDATE accounts SET total = total + 2000 WHERE user_id IS NULL;
-- ***

--  2я сессия -- 
START TRANSACTION;
UPDATE accounts SET total = total - 2000 WHERE user_id = 4;
-- тр.акц. зависнет в ожидании завершения тр.акц. в другой сессии
-- или пока не истечет timeout

--  1я сессия --
COMMIT;
-- ***

--  2я сессия -- 
ROLLBACK;

-- * Взаимоблокировка *
-- В разных БД предусмотренны разные срежства для обнаружения и
-- разрешения взаимных блокировок например timeout


-- * 02. Журнал транзакций *
-- обычно тр.акц. не сразу записывается в таблицу, перед тем
-- как изменения будут зафиксированны в БД они сначала
-- помещаеются в *Журнал транзакций*, т.е. копия, tmp table на диске.

-- Запросить параметры Жуонала Тр.Акц (далее жта)
SHOW VARIABLES LIKE 'innodb_log_%';

-- Получить путь к каталогу данных в системе 
SHOW VARIABLES LIKE 'datadir';
exit;
-- переходим в данный каталог
cd \ProgramData\MySQL\MySQL Server 8.0\Data\
-- в WIN просмотр содержимого каталога
dir


-- * 03. Управление режимом сохранения транзакций *
-- за управление этим режимом отвечает серверная переменная
innodb_flush_log_at_trx_commit
-- значения:
-- 0 = save раз 1 сек
-- 1 = save после кажд тр.акц.
-- 2 = 0 + 1
-- Запросим состяние этой переменной
SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';

-- для изменения значения
-- SET GLOBAL innodb_flush_log_at_trx_commit = 0; -- например



-- * 04. MVCC *
-- Много версионное управление конкурентным доступом
-- это альтернатива механизма блокировок
-- идея в создании мнгновенных снимков состояний
-- в кратце:
-- * операции чтения не требуют никаких блокировок,
-- чтение никогда не блокирует запись, а запись чтение. *
-- чтение и запись могут выпоняться параллельно, без взаимных блокировок

-- !!! MVCC работают только на уровнях !!! --
READ COMMITTED
REPEATABLE READ
-- *
-- 						   ***			    		--


-- ***************************************************
-- *** Урок 6 ч.3 Переменные, временные таблицы и ****
-- ************ динамические запросы *****************
-- ********** сеансовые инструменты MySQL ************
-- 01. Пользовательские переменные
-- 02. Системные переменные
-- 03. Временные таблицы
-- 04. Динамические запросы

-- * 01. Пользовательские переменные * --

-- в переменные можно сохранять возвращаемые запросами структуры
SELECT @total := COUNT(*) FROM products;

-- в дальнейшем мы сможем использ. переменную @total
-- в рамках текущей сессии работы с сервером
SELECT @total;
-- если попытаться обратиться к @total из другой сессии
-- открыв например в другой CMD, то @total = NULL

-- Переменные можно использ. не только после SELECT
SELECT @price := MAX(price) FROM products;
SELECT * FROM products WHERE price = @price;
-- удобный вывод
SELECT * FROM products WHERE price = @price\G

-- Если переменной присвоить столбец таблицы, то в качестве значения
-- будет записано значения из последнего поля этого столбца

-- !!! Имена переменных не чувствительны к регистру !!! --
SELECT @id := 5, @ID := 3;
SELECT @id, @ID; -- 3; 3;

-- Пременные можнообъявлять при помощи оператора SET 
-- отличие в том, что SET не врзвращает таблицу
SET @last = NOW() - INTERVAL 7 DAY;
SELECT CURDATE(), @last;

-- Переменные можно использовть для нумерации записей в таблице
SELECT * from tbl1;
SET @start := 0;
SELECT @start := @start + 1 AS id, value FROM tbl1;


-- * 02. Системные переменные * --
-- Полный список системных переменных
SHOW VARIABLES;
-- Для фильтрации выборки
SHOW VARIABLES LIKE 'read_buffer_size';

-- Типы системных переменных
-- GLOBAL - глобалные (влияет на весь сервер)
-- SESSION - сеансовые (влияет на текущее соединение клиент-сервер)
-- При старте сервера присходит инициализация переменных по умолчанию

-- Для изменения global пременных 
-- SET GLOBAL read_buffer_size = 65536;
-- тоже самое
-- SET @@global.read_buffer_size = 65536;

-- для работы с сессиоными переменными
-- SET SESSION read_buffer_size = 65536;
-- тоже самое
-- SET @@session.read_buffer_size = 65536;

-- Чтобы присвоить локальной пременной значение глобальной переменной
-- SET SESSION read_buffer_size = DEFAULT;



-- * 03. Временные таблицы *
-- 2 разные сессии (2 разных клиента) могут испльз. временные
-- таблицы с одинаковыми  именами или с уже сущ. табл. с тем же 
-- именем.



-- * 04. Динамические запросы *
-- Позваляют сохранять запросы под конктретным именем и
-- вызывать позже в течение сессии.
-- Для объявления динамического запроса использ. команда:
PREPARE ver FROM 'SELECT VERSION()';
-- выполняется такой динамический запрос с помощью
EXECUTE ver;
-- !!! Динамические запросы живут только в течние текущей сессии !!! --
-- Если мы хотим чтобы сохр. данные жили болле оной сессии
-- необходимо прибегнуть к ПРЕДСТАВЛЕНИЯМ, но об этом в след. уроках.

-- ДЗ можно параметризовать
-- ДЗ который извлекает товарные позиции только одного из
-- разделов интернет-магазина
PREPARE prd FROM 'SELECT id, name, price FROM products WHERE catalog_id = ?';
-- Зададим id раздела при помощи пременной
SET @catalog_id = 1;
-- для использ. сохраненных ранее данных
EXECUTE prd USING @catalog_id;


-- ДЗ может иметь более одного параметра 
-- ....

-- Удалить ДЗ
DROP PREPARE prd; 
-- 						   ***			    		--


-- ***************************************************
-- ************ Урок 6 ч.4 Представления *************
-- 01. Создание представлений
-- 02. Вертикальные и Горизонтальные представления
-- 03. Вставка записей в представление
-- 04. Обновление представлений
-- 05. Управление представлениями

-- * 01. Создание представлений *
SELECT * FROM catalogs;
-- представление для табл.catalogs с отсортированными записями
CREATE VIEW cat AS SELECT * FROM catalogs ORDER BY name;

SELECT * FROM cat;

--  представление рассматриваеися Musql как полноценная таблица
-- поэтому мы видим ее в списке таблиц
SHOW TABLES;
-- т.к. при создании пред-я мы исподьз. * она плностью копирует
-- структуру catalogs, но при создании мы можем явно указать структуру столбцов
-- даже измен их назв. и порядок из следования.
CREATE VIEW cat_reverse(catalog, catalog_id)
AS SELECT name, id FROM catalogs;

SELECT * FROM cat_reverse;

-- В качестве столбцов представления могут выступать вычисляемые значения
-- REPLACE На случай если представление с таким именем уже существует 
CREATE OR REPLACE VIEW namecat(id, name, total)
AS SELECT id, name, LENGTH(name) FROM catalogs;

SELECT * FROM namecat;

-- *** Алгоритм формирования конечного запроса *** --
MERGE -- 
TEMPTABLE
UNDEFINED -- использ. по умолчанию

-- Для явного указания алгоритма формирования конечного 
-- результата запроса
CREATE ALGORITHM = TEMPTABLE VIEW cat2
AS SELECT * FROM catalogs; 

-- Представление может скрывать ряд столбцов, за счет того,
-- что могут извлекаться не все столбцы таблицы,
-- такие представления назыв. ВЕРТИКАЛЬНЫЕ
CREATE OR REPLACE VIEW prod AS
SELECT id, name, price, catalog_id
FROM products
ORDER BY catalog_id, name;

SELECT * FROM prod;
-- можно и так
SELECT * FROM prod ORDER BY name DESC;


-- * Горизонтальные представления ограничивают доступ
-- пользоватей к строкам таблиц, в таких представлениях  
-- видимы только те строки с которыми они работают
CREATE OR REPLACE VIEW processors AS
SELECT id, name, price, catalog_id
FROM products
WHERE catalog_id = 1;

SELECT * FROM processors;


-- в практике встречаются и смешанные представления,
-- которые ограничивают таблицу по горзинт. и по вертик.
-- создадим обновляемое представление
-- Для того чтобы в дальнейшем к представление можно было 
-- применять UPDATE или INSERT необходимо при создании использю опцию

CREATE VIEW v1 AS
SELECT * FROM tbl1 WHERE value < 'fst5'
WITH CHECK OPTION;

INSERT INTO v1 VALUES ('fst4'); -- OK
INSERT INTO v1 VALUES ('fst6'); -- fail


-- Отредактировать представление можно при помощи команды ALTER
ALTER VIEW v1 AS
SELECT * FROM tbl1 WHERE value > 'fst4',
WITH CHECK OPTION;
-- синоним
CREATE OR REPLACE VIEW v1 AS
SELECT * FROM tbl1 WHERE value > 'fst4',
WITH CHECK OPTION;

-- Для удаления представления использ.
DROP VIEW cat, cat_reverse, namecat, prod, processors, v1;

